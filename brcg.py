
"""
script infrstructure generated by 
ToolBaz https://toolbaz.com/writer/python-code-generator
"""

import websocket # type: ignore
import json
import os
import threading
import time
import RPi.GPIO as GPIO # type: ignore
import sys
import drivers # type: ignore
import math
from time import sleep



class BinancePriceExtractor:
    def __init__(self, symbol="btcusdt"):
        self.symbol = symbol.lower() # Ensure lowercase for Binance URLs
        self.last_price = None       # Variable to store the last received price
        self.ws_url = f"wss://stream.binance.com:9443/ws/{self.symbol}@ticker"
        self.ws_app = None           # WebSocketApp instance
        self.ws_thread = None        # Thread for WebSocket connection
        self._lock = threading.Lock() # Lock for thread-safe access to last_price
        self.running = False         # Flag to control the WebSocket thread

    def on_message(self, ws, message):
        """Callback when a message is received from the WebSocket."""
        try:
            data = json.loads(message)
            # The 'c' field typically represents the "last price" or "close price"
            if 'c' in data:
                price = float(data['c'])
                with self._lock:
                    self.last_price = price
                # print(f"[{self.symbol.upper()}] New Price Received: {price}")
            # else:
            #     print(f"[{self.symbol.upper()}] Received non-price message: {data.keys()}")

        except json.JSONDecodeError:
            print(f"[{self.symbol.upper()}] Error decoding JSON: {message}")
        except KeyError:
            print(f"[{self.symbol.upper()}] Key 'c' not found in message: {message}")
        except ValueError:
            print(f"[{self.symbol.upper()}] Value error parsing price: {data.get('c', 'N/A')}")
        except Exception as e:
            print(f"[{self.symbol.upper()}] An unexpected error occurred in on_message: {e}")

    def on_error(self, ws, error):
        """Callback when an error occurs."""
        print(f"[{self.symbol.upper()}] WebSocket Error: {error}")

    def on_close(self, ws, close_status_code, close_msg):
        """Callback when the WebSocket connection is closed."""
        print(f"[{self.symbol.upper()}] WebSocket Closed. Code: {close_status_code}, Message: {close_msg}")
        self.running = False # Update running flag

    def on_open(self, ws):
        """Callback when the WebSocket connection is opened."""
        print(f"[{self.symbol.upper()}] WebSocket Connected to {self.ws_url}")

    def _run_websocket(self):
        """Internal method to run the WebSocket connection."""
        self.ws_app = websocket.WebSocketApp(self.ws_url,
                                             on_open=self.on_open,
                                             on_message=self.on_message,
                                             on_error=self.on_error,
                                             on_close=self.on_close)
        # run_forever() blocks the thread until connection is closed
        self.ws_app.run_forever()
        print(f"[{self.symbol.upper()}] WebSocket run_forever() exited.")


    def start(self):
        """Starts the WebSocket connection in a separate thread."""
        if self.running:
            print(f"[{self.symbol.upper()}] WebSocket already running.")
            return

        print(f"[{self.symbol.upper()}] Starting WebSocket thread...")
        self.running = True
        self.ws_thread = threading.Thread(target=self._run_websocket, daemon=True)
        self.ws_thread.start()
        # Give a moment for the connection to establish
        time.sleep(1)

    def stop(self):
        """Stops the WebSocket connection."""
        if self.ws_app:
            print(f"[{self.symbol.upper()}] Stopping WebSocket...")
            self.ws_app.close()
            # self.running flag will be set to False by on_close callback
            if self.ws_thread and self.ws_thread.is_alive():
                self.ws_thread.join(timeout=5) # Wait for thread to finish
                if self.ws_thread.is_alive():
                    print(f"[{self.symbol.upper()}] Warning: WebSocket thread did not terminate cleanly.")
            self.ws_app = None
            self.ws_thread = None
        else:
            print(f"[{self.symbol.upper()}] WebSocket not running.")

    def get_last_price(self):
        """Returns the last known price."""
        with self._lock:
            return self.last_price

def read_config(file_path='settings.json'):   
    if not os.path.exists(file_path):
        print(f"Error: Configuration file '{file_path}' not found.")
        return None    
    try:
        with open(file_path, 'r') as file:
            config_data = json.load(file)
            return config_data
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from '{file_path}'. Check file format.")
        return None
    except Exception as e:
        print(f"An unexpected error occurred while reading '{file_path}': {e}")
        return None
        

SERVO_PIN = 17
PWM_FREQUENCY = 50 # Hz (Standard for most servos is 50Hz, 20ms period)
MIN_DUTY_CYCLE = 3.5  # Example: Duty cycle for 0 degrees (often 2.5% to 5%)
MAX_DUTY_CYCLE = 12.5 # Example: Duty cycle for 180 degrees (often 10% to 12.5%)

def smooth_servo_movement(
    pwm_object,
    start_duty_cycle,
    end_duty_cycle,
    steps=50,
    delay_per_step=0.02,
    min_dc_limit=MIN_DUTY_CYCLE,
    max_dc_limit=MAX_DUTY_CYCLE
):   
    if steps < 1:
        steps = 1 # Ensure at least one step, to avoid division by zero
    # Clamp start and end duty cycles to safe limits
    start_duty_cycle = max(min_dc_limit, min(max_dc_limit, start_duty_cycle))
    end_duty_cycle = max(min_dc_limit, min(max_dc_limit, end_duty_cycle))
    # If already at target, no movement needed
    if abs(start_duty_cycle - end_duty_cycle) < 0.01: # Use a small tolerance for float comparison
        #print(f"Servo already at or very close to target duty cycle: {end_duty_cycle:.2f}%")
        pwm_object.ChangeDutyCycle(end_duty_cycle) # Ensure it's exactly there
        return

    #print(f"Moving servo from {start_duty_cycle:.2f}% to {end_duty_cycle:.2f}% in {steps} steps...")

    duty_cycle_range = end_duty_cycle - start_duty_cycle
    step_increment = duty_cycle_range / steps

    current_duty_cycle = start_duty_cycle

    for i in range(steps):
        current_duty_cycle += step_increment
        
        if (step_increment > 0 and current_duty_cycle > end_duty_cycle) or \
           (step_increment < 0 and current_duty_cycle < end_duty_cycle):
            current_duty_cycle = end_duty_cycle # Cap it at the target for this step

        current_duty_cycle = max(min_dc_limit, min(max_dc_limit, current_duty_cycle))        
        pwm_object.ChangeDutyCycle(current_duty_cycle)
        time.sleep(delay_per_step)
    pwm_object.ChangeDutyCycle(end_duty_cycle)
    #print(f"Servo duty cycle: {end_duty_cycle:.2f}%")




# --- Main execution part ---
if __name__ == "__main__":
    # You can change the symbol here (e.g., "ethusdt", "solusdt")
    display = drivers.Lcd()
    symbol_to_track = "btcusdt" 
    price_extractor = BinancePriceExtractor(symbol=symbol_to_track)
    def num_to_range(num, inMin, inMax, outMin, outMax):
        return outMin + (float(num - inMin) / float(inMax - inMin) * (outMax - outMin))

    try:
        # Start the WebSocket connection in a separate thread
        price_extractor.start()

        print(f"\n--- Monitoring {symbol_to_track.upper()} Price ---")
        print("Press Ctrl+C to stop.")
        
        lastprice = 107000
        lastdiff = 0.0
        oldprice = 107000
        
        optunchanged = ""
        moved = 0

        config = read_config()

        if config:
            setdiff = config.get('setdiff', 0)
            pwm_max = config.get('pwm_max', 0.0)
            pwm_min = config.get('pwm_min', 0.0)
            pwm_center = config.get('pwm_center', 0.0)
            move_type = config.get('move_type', 0)
        else:
            setdiff = 60
            pwm_max = 12.5
            pwm_min = 3.5
            pwm_center = 8.0
            move_type = 0

        lastpwm = pwm_center    
        GPIO.setwarnings(False)
        servoPIN = 17
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(servoPIN, GPIO.OUT)
        servo_pwm = GPIO.PWM(servoPIN, 50)  # 50Hz frequency
        servo_pwm.start(pwm_center)  # Initialization
        time.sleep(0.2)
        servo_pwm.ChangeDutyCycle(0)
        #servo_pwm.stop   # 
        # Main loop to periodically print the price
        cc = drivers.CustomCharacters(display)
        cc.char_1_data = ["01010",
                          "11110",
                          "10001",
                          "11110",
                          "10001",
                          "10001",
                          "11110",
                          "01010"]
        # Custom caracter #2. Code {0x01}.
        # Custom caracter #2. Code {0x01}.
        cc.char_2_data = ["11111",
                          "11111",
                          "01111",
                          "01111",
                          "00111",
                          "00011",
                          "00001",
                          "00001"]

# Custom caracter #3. Code {0x02}.
        cc.char_3_data = ["11111",
                          "11111",
                          "11110",
                          "11110",
                          "11100",
                          "11000",
                          "10000",
                          "10000"]
        # Custom caracter #2. Code {0x03}.
        cc.char_4_data = ["00001",
                          "00011",
                          "00011",
                          "00111",
                          "01111",
                          "01111",
                          "11111",
                          "11111"]

# Custom caracter #3. Code {0x04}.
        cc.char_5_data = ["10000",
                          "11000",
                          "11000",
                          "11100",
                          "11110",
                          "11110",
                          "11111",
                          "11111"]

        cc.load_custom_characters_data()
        display.lcd_display_extended_string("{0x00} {0x00} {0x00} {0x00} {0x00} {0x00} {0x00} {0x00}", 1)
        display.lcd_display_extended_string(" {0x00} {0x00} {0x00} {0x00} {0x00} {0x00} {0x00}", 2)
        time.sleep(2)
        #display.lcd_display_extended_string("{0x00} {0x00} {0x00} {0x00} {0x00} {0x00} {0x00} {0x00}", 2)
        display.lcd_display_string("                ",1)
        display.lcd_display_string("                ",2)
        
        while True:
            current_price = price_extractor.get_last_price()
            if current_price is not None:
                # This demonstrates "printing in next call" or "accessing the var"
                if lastprice == 107000:
                    lastprice = current_price

                #display.lcd_clear()
                if lastprice != current_price:

                    display.lcd_display_string("                ",1)
                    display.lcd_display_string("".join(["$", str(current_price)," USD"]), 1)
                    #display.lcd_display_extended_string("= {{0x00}}1 BTC".format(5), 2)

                
            
                diff = round(current_price - lastprice,1)
                oldm = round(current_price - lastprice,2)
                #print(diff, " ", lastdiff, " ", lastpwm)
                if diff < 0 and lastdiff < 0:
                    diff = diff + lastdiff
                    lastdiff = diff
                if diff > 0 and lastdiff > 0:
                    diff = diff + lastdiff
                    lastdiff = diff

                oldprice = diff
                lastdiff = diff
                lastdiff = round(lastdiff,1)
                oldm = math.ceil(oldm * 100) / 100
                if diff < -0.5:
                    display.lcd_display_string("                ",2)
                    #display.lcd_display_string(f"".join(["v $", str(oldprice)]),2)
                    display.lcd_display_extended_string("           {0x01}{0x02}",2)
                    display.lcd_display_string(f" ${str(oldm)}",2)
                if diff > 0.5:
                    display.lcd_display_string("                ",2)
                    display.lcd_display_extended_string("           {0x03}{0x04}",2)
                    display.lcd_display_string(f"  ${str(oldm)}",2)


                if diff > setdiff:
                    diff = setdiff - 1
                if diff < setdiff * -1:
                    diff = (setdiff * -1) + 1
                #print("range +/- 300 ", diff)
                pwm = num_to_range(diff,setdiff * -1,setdiff,pwm_min,pwm_max)
                pwm = round(pwm, 2)
                
                print(f"",pwm, " ",lastpwm," ", diff)
                if move_type == 0:
                    #servo_pwm.ChangeDutyCycle(pwm)
                    smooth_servo_movement(servo_pwm, lastpwm, pwm, steps=abs(int(pwm - lastpwm) * 20), delay_per_step=0.025)
                    time.sleep(0.3)
                    lastpwm = pwm
                    servo_pwm.ChangeDutyCycle(0)
                else:
                    if not(pwm > 7.95 and pwm < 8.05):
                        #servo_pwm.ChangeDutyCycle(pwm)
                        smooth_servo_movement(servo_pwm, lastpwm, pwm, steps=abs(int(pwm - lastpwm) * 20), delay_per_step=0.025)
                        time.sleep(0.3)
                        lastpwm = pwm
                        servo_pwm.ChangeDutyCycle(0)
                

                     
                
                #print("pwm  ", pwm)
                #print(current_price, " ", pwm," ",round(diff, 1))
                #print(" ")
                oldprice = lastprice
                lastprice = current_price
            else:
                print(f"Waiting for {symbol_to_track.upper()} price data...")

            time.sleep(1) # Wait for 2 seconds before checking again

    except KeyboardInterrupt:
        print("\nCtrl+C detected. Stopping...")
    except Exception as e:
        print(f"An error occurred in the main loop: {e}")
    finally:
        # Ensure the WebSocket connection is properly closed on exit
        price_extractor.stop()
        print("Application stopped.")
        display.lcd_display_string("stopped         ",1)
        display.lcd_display_string("                ",2)
        sys.exit(0)